{"version":3,"sources":["eq.min.js"],"names":["eqjs","EQjs","this","nodes","eqsLength","widths","points","callback","undefined","addEvent","elem","event","fn","addEventListener","attachEvent","call","window","parseBefore","getComputedStyle","getPropertyValue","slice","mergeNodes","a","b","concat","prototype","query","length","proto","Object","getPrototypeOf","nodesLength","i","push","offsetWidth","sortObj","getAttribute","e","e2","key","value","nodeWrites","requestAnimationFrame","j","k","eqResizeEvent","eqState","objWidth","obj","eqPts","eqStates","eqPtsLength","join","current","next","removeAttribute","setAttribute","CustomEvent","detail","bubbles","dispatchEvent","refreshNodes","cssNodes","document","querySelectorAll","querySelector","split","forEach","v","arr","objSplit","sSplit","replace","parseFloat","sort","module","exports","define","amd","breakjs"],"mappings":"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","file":"eq.min.js","sourcesContent":["/*! eq.js v1.7.1 (c) 2013-2016 Sam Richard, MIT license */\n/*\n * The global eqjs object that contains all eq.js functionality.\n *\n * eqjs.nodes - List of all nodes to act upon when eqjs.states is called\n * eqjs.nodesLength - Number of nodes in eqjs.nodes\n *\n * eqjs.refreshNodes - Call this function to refresh the list of nodes that eq.js should act on\n * eqjs.sortObj - Sorts a key: value object based on value\n * eqjs.query - Runs through all nodes and finds their widths and points\n * eqjs.nodeWrites - Runs through all nodes and writes their eq status\n */\n(function (eqjs) {\n  'use strict';\n\n  function EQjs() {\n    this.nodes = [];\n    this.eqsLength = 0;\n    this.widths = [];\n    this.points = [];\n    this.callback = undefined;\n  }\n\n  /*\n   * Add event (cross browser)\n   * From http://stackoverflow.com/a/10150042\n   */\n  function addEvent(elem, event, fn) {\n    if (elem.addEventListener) {\n      elem.addEventListener(event, fn, false);\n    } else {\n      elem.attachEvent('on' + event, function () {\n        // set the this pointer same as addEventListener when fn is called\n        return (fn.call(elem, window.event));\n      });\n    }\n  }\n\n  /*\n   * Parse Before\n   *\n   * Reads `:before` content and splits it at the comma\n   * From http://jsbin.com/ramiguzefiji/1/edit?html,css,js,output\n   */\n  function parseBefore(elem) {\n    return window.getComputedStyle(elem, ':before').getPropertyValue('content').slice(1, -1);\n  }\n\n  /*\n   * Merges two node lists together.\n   *\n   * From http://stackoverflow.com/questions/914783/javascript-nodelist/17262552#17262552\n   */\n  var mergeNodes = function(a, b) {\n    return [].slice.call(a).concat([].slice.call(b));\n  };\n\n  /*\n   * Query\n   *\n   * Reads nodes and finds the widths/points\n   *  nodes - optional, an array or NodeList of nodes to query\n   *  callback - Either boolean (`true`/`false`) to force a normal callback, or a function to use as a callback once query and nodeWrites have finished.\n   */\n  EQjs.prototype.query = function (nodes, callback) {\n    var proto = Object.getPrototypeOf(eqjs);\n    var length;\n\n    if (callback && typeof(callback) === 'function') {\n      proto.callback = callback;\n    }\n\n    if (nodes && typeof(nodes) !== 'number') {\n      length = nodes.length;\n    }\n    else {\n      nodes = proto.nodes;\n      length = proto.nodesLength;\n    }\n    var widths = [], points = [], i;\n\n    for (i = 0; i < length; i++) {\n      widths.push(nodes[i].offsetWidth);\n      try {\n        points.push(proto.sortObj(nodes[i].getAttribute('data-break-pts')));\n      }\n      catch (e) {\n        try {\n          points.push(proto.sortObj(parseBefore(nodes[i])));\n        }\n        catch (e2) {\n          points.push([{\n            key: '',\n            value: 0\n          }]);\n        }\n      }\n    }\n\n    proto.widths = widths;\n    proto.points = points;\n\n    if (nodes && typeof(nodes) !== 'number') {\n      proto.nodeWrites(nodes, widths, points);\n    }\n    else if (callback && typeof(callback) !== 'function') {\n      proto.nodeWrites();\n    }\n    else {\n      window.requestAnimationFrame(proto.nodeWrites);\n    }\n  };\n\n  /*\n   * NodeWrites\n   *\n   * Writes the data attribute to the object\n   *  nodes - optional, an array or NodeList of nodes to query\n   *  widths - optional, widths of nodes to use. Only used if `nodes` is passed in\n   *  points - optional, points of nodes to use. Only used if `nodes` is passed in\n   */\n  EQjs.prototype.nodeWrites = function (nodes) {\n    var i,\n        j,\n        k,\n        length,\n        callback,\n        eqResizeEvent,\n        eqState,\n        proto = Object.getPrototypeOf(eqjs),\n        widths = proto.widths,\n        points = proto.points;\n\n    if (nodes && typeof(nodes) !== 'number') {\n      length = nodes.length;\n    }\n    else {\n      nodes = proto.nodes;\n      length = proto.nodesLength;\n    }\n\n    for (i = 0; i < length; i++) {\n      // Set object width to found width\n      var objWidth = widths[i];\n      var obj = nodes[i];\n      var eqPts = points[i];\n      var eqStates = [];\n\n      // Get keys for states\n      var eqPtsLength = eqPts.length;\n\n      // Be greedy for smallest state\n      if (objWidth < eqPts[0].value) {\n        eqState = null;\n      }\n      // Be greedy for largest state\n      else if (objWidth >= eqPts[eqPtsLength - 1].value) {\n        for (k = 0; k < eqPtsLength; k++) {\n          eqStates.push(eqPts[k].key);\n        }\n        eqState = eqStates.join(' ');\n      }\n      // Traverse the states if not found\n      else {\n        for (j = 0; j < eqPtsLength; j++) {\n          var current = eqPts[j];\n          var next = eqPts[j + 1];\n          eqStates.push(current.key);\n\n          if (j === 0 && objWidth < current.value) {\n            eqState = null;\n            break;\n          }\n          else if (next.value === undefined) {\n            eqStates.push(next.key);\n            eqState = eqStates.join(' ');\n            break;\n          }\n          else if (objWidth >= current.value && objWidth < next.value) {\n            eqState = eqStates.join(' ');\n            break;\n          }\n        }\n      }\n\n      // Determine what to set the attribute to\n      if (eqState === null) {\n        obj.removeAttribute('data-eq-state');\n      }\n      else {\n        obj.setAttribute('data-eq-state', eqState);\n      }\n      // Set the details of `eqResize`\n      eqResizeEvent = new CustomEvent('eqResize', {'detail': eqState, 'bubbles': true});\n\n      // Fire resize event\n      obj.dispatchEvent(eqResizeEvent);\n    }\n\n    // Run Callback\n    if (proto.callback) {\n      callback = proto.callback;\n      proto.callback = undefined;\n      callback(nodes);\n    }\n  };\n\n  /*\n   * Refresh Nodes\n   * Refreshes the list of nodes for eqjs to work with\n   */\n  EQjs.prototype.refreshNodes = function () {\n    var proto = Object.getPrototypeOf(eqjs),\n        cssNodes = [];\n\n    proto.nodes = document.querySelectorAll('[data-break-pts]');\n\n    cssNodes = parseBefore(document.querySelector('html')).split(', ');\n    cssNodes.forEach(function (v) {\n      if (v !== '') {\n        proto.nodes = mergeNodes(proto.nodes, document.querySelectorAll(v));\n      }\n    });\n\n\n    proto.nodesLength = proto.nodes.length;\n  };\n\n  /*\n   * Sort Object\n   * Sorts a simple object (key: value) by value and returns a sorted object\n   */\n  EQjs.prototype.sortObj = function (obj) {\n    var arr = [];\n\n    var objSplit = obj.split(',');\n\n    for (var i = 0; i < objSplit.length; i++) {\n      var sSplit = objSplit[i].split(':');\n      arr.push({\n        'key': sSplit[0].replace(/^\\s+|\\s+$/g, ''),\n        'value': parseFloat(sSplit[1])\n      });\n    }\n\n    return arr.sort(function (a, b) { return a.value - b.value; });\n  };\n\n  /*\n   * We only ever want there to be\n   * one instance of EQjs in an app\n   */\n  eqjs = eqjs || new EQjs();\n\n  /*\n   * Document Loaded\n   *\n   * Fires on document load; for HTML based EQs\n   */\n  addEvent(window, 'DOMContentLoaded', function () {\n    eqjs.refreshNodes();\n    eqjs.query(undefined, true);\n  });\n\n  /*\n   * Window Loaded\n   */\n  addEvent(window, 'load', function () {\n    eqjs.refreshNodes();\n    eqjs.query(undefined, true);\n  });\n\n  /*\n   * Window Resize\n   *\n   * Loop over each `break-pts` element and pass to eqState\n   */\n  addEvent(window, 'resize', function () {\n    eqjs.refreshNodes();\n    window.requestAnimationFrame(eqjs.query);\n  });\n\n  // Expose 'eqjs'\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = eqjs;\n  } else if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return eqjs;\n    });\n  } else {\n    window.breakjs = eqjs;\n  }\n})(window.breakjs);\n"],"sourceRoot":"/source/"}